This small library can be used to inspect arbitrary OCaml values,
either by dumping the object graph as pretty printed S-expressions
with references and sharing (see {!module: Sexpr}), or by generating output in the
DOT-language to be further processed by {e Graphviz} (see {!module: Dot})
sub-modules.

{!indexlist}
{!modules: Value Sexpr Dot Aux}

{2 Low-level Representation of OCaml Values}

OCaml values all share a common low-level representation. In contrast
to dynamically typed languages, it is usually not possible to infer
the type of a value from the low-level representation, because several
distinct OCaml types can share the same representation. This is not
really an issue, because OCaml is statically typed after all. So
except for some trickery with [Obj.magic], it is simply not possible
to apply a function to a value of the wrong type.

{3 The Value Type}

The basic building block that is used by the runtime-system (which is
written in the C programming language) to represent any value in the
OCaml universe is the value type. Values are always word-sized. A word
is either 32 or 64 bits wide, depending on the architecture (see
[Sys.word_size]).

A value can either be a pointer to a block of values in the OCaml
heap, a pointer to an object outside of the heap, or an unboxed
integer. Naturally, blocks in the heap are garbage-collected.

To distinguish between unboxed integers and pointers, the system uses
the least-significant bit of the value as a flag. If the LSB is set,
the value is unboxed. If the LSB is cleared, the value is a pointer to
some other region of memory. This encoding also explains why the int
type in OCaml is only 31 bits wide (63 bits wide on 64 bit platforms).

Because blocks in the heap are garbage-collected, they have strict
structure constraints. Information like the tag of a block and its
size (in words) is encoded in the header of each block.

There are two categories of blocks with respect to the garbage collector:

- {b Structured blocks} may only contain well-formed values, as they are
  recursively traversed by the garbage collector.

- {b Raw blocks} are not scanned by the garbage collector, and can thus
  contain arbitrary values.

Structured blocks have tag values lower than [Obj.no_scan_tag], while
raw blocks have tags equal or greater than [Obj.no_scan_tag].

{4 Blocks in the Heap}

The chapter on {Interfacing C with Objective Caml} in the {e OCaml
manual} describes the following types of blocks. The type of a block
is its tag, which is stored in the block header. (see [Obj.tag]).

- [0] to [Obj.no_scan_tag-1], A structured block (an array of Caml
objects). Each field is a value.

- [Obj.closure_tag]: A closure representing a functional value. The
first word is a pointer to a piece of code, the remaining words are
values containing the environment.

- [Obj.string_tag]: A character string.

- [Obj.double_tag]: A double-precision floating-point number.

- [Obj.double_array_tag]: An array or record of double-precision
floating-point numbers.

- [Obj.abstract_tag]: A block representing an abstract datatype.

- [Obj.custom_tag]: A block representing an abstract datatype with
user-defined finalization, comparison, hashing, serialization and
deserialization functions atttached.

There are a few more structured block types which are not directly
described in the {e manual}.

- [Obj.object_tag]: A structured block representing an object. The first
  field is a value that describes the class of the object. The second
  field is a unique object id (see [Oo.id]). The rest of the block
  represents the variables of the object.

- [Obj.lazy_tag], [Obj.forward_tag]: These two block types are used by the
runtime-system to implement lazy-evaulation.

- [Obj.infix_tag]: A special block contained within a closure block, used only
by the GC.

{4 Representation of OCaml Values}

This section is only a summary of the most important things.  The
chapter on {e Interfacing C with Objective Caml} in the {e OCaml manual}
gives a much better explanation over the translation of OCaml types to
their actual representation.

{ul
{li {b Atomic types}
    {ul
    {li {b [int]}: Unboxed integer values.}
    {li {b [char]}: Unboxed integer values (ASCII code).}
    {li {b [float]}: Blocks with tag [Obj.double_tag].}
    {li {b [string]}: Blocks with tag [Obj.string_tag].}
    {li {b [int32]/[int64]/[nativeint]}: Blocks with [Obj.custom_tag].}
    }}
{li {b Tuples and records}: Blocks with tag 0.}
{li {b Arrays} Blocks with tag 0.}
{li {b Arrays and records of floats}: Blocks with tag [Obj.double_array_tag]}
{li {b Concrete types}
    {ul
    {li {b Constant constructors}: Represented by unboxed integers, first declared constant constructor is 0.}
    {li {b Non-constant constructors}:
    	Blocks with a tag lower than [Obj.no_scan_tag] that encodes the constructor, starting at 0}.
    {li {b E.g. [type t = A | B of int | C | D of int * string]}
    	{ul
	{li [Obj.repr A = Obj.repr 0]}
	{li [Obj.repr C = Obj.repr 1]}
	{li [let r = Obj.repr (B 1) in Obj.is_block r && Obj.tag r = 0]}
	{li [let r = Obj.repr (D (1,"Str")) in Obj.is_block r && Obj.tag r = 1]}
	}}
    {li {b [bool]}
    	{ul
	{li [Obj.repr false = Obj.repr 0]}
	{li [Obj.repr true == Obj.repr 1]}
	}}
    {li {b [unit]}
    	{ul
	{li [Obj.repr () == Obj.repr 0]}
	}}
    {li {b ['a list]}
    	{ul
	{li [Obj.repr [] == Obj.repr 0]}
        {li [h::t]: Block with tag 0 and size 2. First field is [h], second field [t].}
	}}
    }}

{li {b Objects}: Blocks with tag [Obj.object_tag]. The first field
refers to the class of the object and its assosicated method
suite. The second field contains a unique object ID. The remaining
fields are the instance variables of the object.}

{li {b Variants}: Variants are similar to constructed terms. There are a few differences however.
    {ul

    {li Variant constructors are identified by their hash value.}

    {li Non-constant variant constructors are not flattened. They are
    always blocks of size 2, where the first field is the hash. The
    second field can either contain a single value, or a pointer to
    another structured block (just like a tuple). }

    }}
}

{2 References}

Graphviz, Graph Visualization Software
{{:http://www.graphviz.org/}http://www.graphviz.org/}

The Objective Caml system (release 3.11), Documentation and user's manual
{{:http://caml.inria.fr/pub/docs/manual-ocaml/}http://caml.inria.fr/pub/docs/manual-ocaml/}


