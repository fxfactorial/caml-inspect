{"name":"Caml-Inspect","tagline":"Inspection of internal value representations and the object graph","body":"Inspect is a small library to inspect arbitrary OCaml values and their\r\nassociated object graph by either dumping them as S-expressions (with\r\nsharing and references), or by writing output in the DOT-language\r\nwhich can then be further processed by [Graphviz](). Inspect provides\r\na window into the OCaml runtime system, a view behind the curtains,\r\nusable from the toplevel as well.\r\n\r\nKaspar M. Rohrer (<kaspar.rohrer@gmail.com>) is the original author\r\nand currently also the maintainer of this library.\r\n\r\nInstallation\r\n----------------------------------------------------------------------\r\n\r\nIf you have OPAM installed, you should be able to simply do\r\n\r\n    opam install inspect\r\n\r\nIf that should not be the case, either download an apropriate source archive form the [project homepage][Homepage] and unzip or untar in any directory, or clone the [git repository][GitRepository], then run\r\n\r\n    make\r\n\r\nto generate the library and documentation.\r\nTo install the library using findlib, simply type\r\n\r\n    make install\r\n\r\nAnd to uninstall it\r\n\r\n    make uninstall\r\n\r\nFor development, you may instead run\r\n\r\n    sudo ln -s `pwd` `ocamlfind printconf path`/inspect\r\n\r\nUsage\r\n----------------------------------------------------------------------\r\n\r\n_Note: [The source-code documentation](doc/html/inspect/index.html) is\r\navailable online, as well._\r\n\r\nIf you have findlib installed, using the library is as simple as\r\ntyping\r\n\r\n    #use \"topfind\";;\r\n    #require \"inspect\";;\r\n\r\ninto your OCaml prompt. I suggest you open the Inspect module as well.\r\n\r\n    open Inspect;;\r\n\r\nFor starters, both the Dot and the Sexpr library provide a test_data\r\nfunction to generate some interesting data to dump.\r\n\r\n    Sexpr.dump (Sexpr.test_data ());;\r\n    Dot.dump (Dot.test_data ());;\r\n\r\nIt is possible to let the dump functions inspect themselves but I'm\r\nless and less sure that this is a good idea, as there's a lot of\r\nmutation going on behind closed doors, which might confuse the current\r\nobject graph walker.\r\n\r\nIf you are on a Mac, the Inspect.Dot.dump_osx function should be of\r\ninterest. It writes the DOT output to a temporary file, uses Graphviz\r\nto generate the graph, and displays the results using the open\r\ncommand.\r\n\r\n    Dot.dump_osx Dot.dump_osx;;\r\n\r\nIt goes without saying that you should have [Graphviz][] installed for\r\nthis last part to work.\r\n\r\n\r\nRepresentation of OCaml Values\r\n----------------------------------------------------------------------\r\n\r\nOCaml values all share a common low-level representation. In contrast\r\nto dynamically typed languages, it is usually not possible to infer\r\nthe type of a value from the low-level representation, because several\r\ndistinct OCaml types can share the same representation. This is not\r\nreally an issue, because OCaml is statically typed after all. So\r\nexcept for some trickery with `Obj.magic`, it is simply not possible\r\nto apply a function to a value of the wrong type.\r\n\r\n### The Value Type\r\n\r\nThe basic building block that is used by the runtime-system (which is\r\nwritten in the C programming language) to represent any value in the\r\nOCaml universe is the value type. Values are always word-sized. A word\r\nis either 32 or 64 bits wide, depending on the architecture (see\r\n`Sys.word_size`).\r\n\r\nA value can either be a pointer to a block of values in the OCaml\r\nheap, a pointer to an object outside of the heap, or an unboxed\r\ninteger. Naturally, blocks in the heap are garbage-collected.\r\n\r\nTo distinguish between unboxed integers and pointers, the system uses\r\nthe least-significant bit of the value as a flag. If the LSB is set,\r\nthe value is unboxed. If the LSB is cleared, the value is a pointer to\r\nsome other region of memory. This encoding also explains why the int\r\ntype in OCaml is only 31 bits wide (63 bits wide on 64 bit platforms).\r\n\r\nBecause blocks in the heap are garbage-collected, they have strict\r\nstructure constraints. Information like the tag of a block and its\r\nsize (in words) is encoded in the header of each block.\r\n\r\nThere are two categories of blocks with respect to the garbage collector:\r\n\r\n- **Structured blocks** may only contain well-formed values, as they are\r\n  recursively traversed by the garbage collector.\r\n- **Raw blocks** are not scanned by the garbage collector, and can thus\r\n  contain arbitrary values.\r\n\r\nStructured blocks have tag values lower than `Obj.no_scan_tag`, while\r\nraw blocks have tags equal or greater than `Obj.no_scan_tag`.\r\n\r\n### Heap Blocks\r\n\r\nThe chapter on *Interfacing C with Objective Caml* in the [OCaml\r\nmanual][OCamlManual] describes the following types of blocks. The type\r\nof a block is its tag, which is stored in the block header. (see\r\n`Obj.tag`).\r\n\r\n- `0` to `Obj.no_scan_tag-1`, A structured block (an array of Caml\r\nobjects). Each field is a value.\r\n- `Obj.closure_tag`: A closure representing a functional value. The\r\nfirst word is a pointer to a piece of code, the remaining words are\r\nvalues containing the environment.\r\n- `Obj.string_tag`: A character string.\r\n- `Obj.double_tag`: A double-precision floating-point number.\r\n- `Obj.double_array_tag`: An array or record of double-precision\r\nfloating-point numbers.\r\n- `Obj.abstract_tag`: A block representing an abstract datatype.\r\n- `Obj.custom_tag`: A block representing an abstract datatype with\r\nuser-defined finalization, comparison, hashing, serialization and\r\ndeserialization functions atttached.\r\n\r\nThere are a few more structured block types which are not directly\r\ndescribed in the [manual][OCamlManual].\r\n\r\n- `Obj.object_tag`: A structured block representing an object. The first\r\n  field is a value that describes the class of the object. The second\r\n  field is a unique object id (see `Oo.id`). The rest of the block\r\n  represents the variables of the object.\r\n- `Obj.lazy_tag`, `Obj.forward_tag`: These two block types are used by the\r\nruntime-system to implement lazy-evaulation.\r\n- `Obj.infix_tag`: A special block contained within a closure block. \r\n\r\n### Summary\r\n\r\nThis section is only a summary of the most important things.  The\r\nchapter on *Interfacing C with Objective Caml* in the [OCaml\r\nmanual][OCamlManual] gives a much better explanation over the\r\ntranslation of OCaml types to their actual representation.\r\n\r\n+ **Atomic types**\r\n  + `int`: Unboxed integer values.\r\n  + `char`: Unboxed integer values (ASCII code).\r\n  + `float`: Blocks with tag `Obj.double_tag`.\r\n  + `string`: Blocks with tag `Obj.string_tag`.\r\n  + `int32`/`int64`/`nativeint`: Blocks with `Obj.custom_tag`.\r\n+ **Tuples and records**: Blocks with tag 0.\r\n+ **Arrays**: Blocks with tag 0.\r\n+ **Arrays and records of floats**: Blocks with tag\r\n`Obj.double_array_tag`.\r\n+ **Concrete types**\r\n    + *Constant constructors*: Represented by unboxed integers, first\r\n    declared constant constructor is 0, second declared constant\r\n    constructor is 1, and so on.\r\n    + *Non-constant constructors*: Blocks with a tag lower than\r\n    `Obj.no_scan_tag` that encodes the constructor, numbered in order\r\n    of declaration, starting at 0.\r\n+ **Objects**: Blocks with tag `Obj.object_tag`. The first field\r\nrefers to the class of the object and its associated method\r\nsuite. The second field contains a unique object ID. The remaining\r\nfields are the instance variables of the object.\r\n+ **Variants**: Variants are similar to constructed terms. There are a\r\nfew differences however.\r\n    + Variant constructors are identified by their hash value.\r\n    + Non-constant variant constructors are not flattened. They are\r\n    always blocks of size 2, where the first field is the hash. The\r\n    second field can either contain a single value, or a pointer to\r\n    another structured block (just like a tuple).\r\n\r\nIf in doubt, dump it out.\r\n\r\nReferences\r\n----------------------------------------------------------------------\r\n\r\n* [OCaml Manual][OCamlManual] - The Objective Caml system, Documentation and user's manual\r\n* [Graphviz][] - Graph Visualization Software\r\n* [Caml-Inspect][] - Source code repository for OCaml Inspect\r\n* [Homepage][] - Project homepage\r\n\r\n[OCamlManual]: http://caml.inria.fr/pub/docs/manual-ocaml/ \"OCaml Manual\"\r\n[Graphviz]: http://www.graphviz.org/ \"Graphviz - Graph Visualization Software\"\r\n[Caml-Inspect]: http://github.com/krohrer/caml-inspect \"Source code repository\"\r\n[GitRepository]: http://github.com/krohrer/caml-inspect\r\n[Homepage]: http://krohrer.github.com/caml-inspect\r\n\r\nLicence\r\n----------------------------------------------------------------------\r\n\r\n> This library is free software; you can redistribute it and/or\r\n> modify it under the terms of the GNU Lesser General Public\r\n> License as published by the Free Software Foundation; either\r\n> version 2.1 of the License, or (at your option) any later version,\r\n> with the special exception on linking described in file LICENSE.\r\n\r\n> This library is distributed in the hope that it will be useful,\r\n> but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n> MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\r\n> Lesser General Public License for more details.\r\n \r\n> You should have received a copy of the GNU Lesser General Public\r\n> License along with this library; if not, write to the Free Software\r\n> Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}